<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Patchwork</title>
  <link rel="stylesheet" href="/static/water.css" />
</head>

<body>
  <img style="float: right" src="./android-chrome-192x192.png" alt="Patchwork logo" width="96" height="96" />
  <h1>Patchwork</h1>
  <p>
    A simple communication backend for scripts and other small applications.
    Patchwork enables IFTTT-type applications by providing infinite HTTP endpoints
    that serve as a multi-process, multi-consumer (MPMC) queue.
  </p>

  <h2>What does it do?</h2>
  <p>
    Patchwork provides infinite HTTP endpoints that can be used to implement powerful
    serverless applications - including desktop notifications, SMS notifications,
    job queues, web hosting, and file sharing. These applications are basically
    just a few lines of bash that wrap a <code>curl</code> command.
  </p>

  <h2>Basics</h2>
  <p>
    The philosophy behind this is that the main logic happens on the local machine
    with small scripts. There is a server with an infinite number of virtual channels
    that will relay messages between the publisher and the subscriber.
  </p>
  
  <p>To subscribe to a channel you can simply make a <code>GET</code> request:</p>
  <pre>curl {{.BaseURL}}/p/a61b1f42</pre>
  
  <p>The above will block until something is published to the channel <code>a61b1f42</code>. 
  You can easily publish to a channel using a <code>POST</code> request:</p>
  <pre>curl {{.BaseURL}}/p/a61b1f42 -d "hello, world"</pre>
  
  <p>The subscriber will immediately receive that data. If you reverse the order,
  then the post will block until it is received.</p>

  <h3>Pubsub mode</h3>
  <p>
    The default mode is a MPMC queue, where the first to connect are able to
    publish/subscribe. But you can also specify publish-subscribe (pubsub) mode.
    In pubsub mode, the publisher will become non-blocking and their data will be
    transmitted to each connected subscriber:
  </p>
  <pre>curl {{.BaseURL}}/p/a61b1f42?pubsub=true -d "hello, world"</pre>

  <h3>Publish with GET</h3>
  <p>
    You can also publish with a <code>GET</code> request by using the parameter
    <code>body=X</code>, making it easier to write href links that can trigger hooks:
  </p>
  <pre>curl {{.BaseURL}}/p/a61b1f42?pubsub=true&body=hello,%20world</pre>

  <h2>Namespaces</h2>
  <p>The server is organized by namespaces with different access patterns:</p>
  <ul>
    <li>
      <strong>/p/**</strong>: Public namespace - no authentication required.
      Everyone can read and write. Perfect for testing and public communication channels.
    </li>
    <li>
      <strong>/h/**</strong>: Forward hooks - GET <code>/h</code> to obtain a new channel and secret,
      then use the secret to POST data to that channel. Anyone can GET data from the channel.
      Useful for webhooks and notifications where you want to control who can send.
    </li>
    <li>
      <strong>/r/**</strong>: Reverse hooks - GET <code>/r</code> to obtain a new channel and secret,
      then anyone can POST data to that channel. Use the secret to GET data from the channel.
      Useful for collecting data from multiple sources where you want to control who can read.
    </li>
    <li>
      <strong>/u/{username}/**</strong>: User namespace - controlled by ACL lists
      (not implemented yet). Access is controlled by YAML ACL files stored in
      Forgejo/Gitea repositories that specify which tokens can access which paths.
    </li>
    <li>
      <strong>/huproxy/{user}/{host}/{port}</strong>: HTTP-to-TCP WebSocket proxy for tunneling SSH and other protocols.
      Based on Google's HUProxy project, this endpoint provides WebSocket tunneling primarily for SSH
      connections. Uses token-based authentication via <code>Authorization</code> header. Tokens are managed through
      a <code>huproxy.yaml</code> file in the user's <code>.patchwork</code> repository.
    </li>
  </ul>

  <h3>User Namespaces</h3>
  <p>
    For user namespaces (<code>/u/{username}/</code>), access is controlled by tokens
    that you configure in your own <code>.patchwork</code> repository. Create a 
    <code>.patchwork</code> repository in your account and add an <code>auth.yaml</code> 
    file to define which tokens can access which paths.
  </p>
  
  <h4>auth.yaml Format</h4>
  <p>Create an <code>auth.yaml</code> file in your <code>.patchwork</code> repository:</p>
  <pre>tokens:
  "my_app_token":
    is_admin: false
    POST: 
      - "/projects/*/logs"    # Can POST to any project's logs
      - "/webhooks/*"         # Can POST to webhook endpoints
    GET: 
      - "/projects/myapp/**"  # Can GET from all myapp paths
      - "!/projects/myapp/secret/**" # But not from secret paths
      
  "readonly_token":
    is_admin: false
    POST: []               # No POST access
    GET: 
      - "*"               # Can GET from all paths
      
  "admin_token":
    is_admin: true
    POST: ["*"]
    GET: ["*"]</pre>
  
  <p>
    Use OpenSSH-style glob patterns to control access: <code>**</code> matches everything, 
    <code>*</code> matches one level, empty array <code>[]</code> denies access.
    These follow the same pattern matching rules as OpenSSH configuration files.
  </p>
  
  <p>
    Example token usage:
  </p>
  <pre>curl {{.BaseURL}}/u/alice/projects/logs?token=my_app_token -d "Deploy completed"</pre>

  <h2>Modes</h2>
  <p>Each endpoint supports multiple modes:</p>
  <ul>
    <li><strong>queue</strong>: Each message is received by exactly one receiver (default)</li>
    <li><strong>pubsub</strong>: All receivers receive the published message</li>
    <li><strong>req/res</strong>: Request/response pattern (not implemented yet)</li>
  </ul>

  <h2>Examples</h2>

  <h3>File Sharing</h3>
  <p>Sending a file:</p>
  <pre>curl -X POST --data-binary "@test.txt" {{.BaseURL}}/p/test.txt</pre>
  <p>Receiving a file:</p>
  <pre>wget {{.BaseURL}}/p/test.txt</pre>

  <h3>Desktop Notifications (Linux)</h3>
  <pre>#!/bin/bash
MAGIC="notify"
URL="{{.BaseURL}}/p/notifications"

while [ 1 ]
do
  X="$(curl $URL)"
  if [[ $X =~ ^$MAGIC ]]; then
    Y="$(echo "$X" | sed "s/$MAGIC*//")"
    notify-send "$Y"
  else
    sleep 10
  fi
done</pre>

  <h3>Job Queue</h3>
  <p>Adding jobs to a queue:</p>
  <pre>#!/bin/bash
for filename in *.mp3
do
  curl {{.BaseURL}}/p/jobs -d $filename
done</pre>

  <p>Processing jobs from the queue:</p>
  <pre>#!/bin/bash
while true
do
  filename=$(curl -s {{.BaseURL}}/p/jobs)
  if [ "$filename" != "Too Many Requests" ]
  then
    echo "Processing: $filename"
    # Process the file here
    ffmpeg -i "$filename" "$filename.ogg"
  else
    sleep 1
  fi
done</pre>

  <h3>Forward Hook Example</h3>
  <p>To use forward hooks, first obtain a channel and secret:</p>
  <pre># Get a new channel and secret
curl {{.BaseURL}}/h
# Returns: {"channel":"abc123-def456-...","secret":"sha256hash..."}

# Send notification (requires secret)
curl {{.BaseURL}}/h/abc123-def456-...?secret=sha256hash... -d "Server is down!"

# Anyone can listen for notifications
curl {{.BaseURL}}/h/abc123-def456-...</pre>

  <h3>Reverse Hook Example</h3>
  <p>Similarly, for reverse hooks, obtain a channel and secret:</p>
  <pre># Get a new channel and secret
curl {{.BaseURL}}/r
# Returns: {"channel":"xyz789-abc123-...","secret":"sha256hash..."}

# Anyone can submit metrics
curl {{.BaseURL}}/r/xyz789-abc123-... -d "cpu:85%"
curl {{.BaseURL}}/r/xyz789-abc123-... -d "memory:67%"

# Reading requires secret
curl {{.BaseURL}}/r/xyz789-abc123-...?secret=sha256hash...</pre>

  <p><strong>Note</strong>: The secrets are generated using HMAC-SHA256 with a server secret key and the channel name. 
  Set the <code>SECRET_KEY</code> environment variable to ensure secrets persist across server restarts.</p>

  <h3>SSH over WebSocket Tunneling</h3>
  <p>The huproxy endpoint allows you to tunnel SSH and other TCP protocols through HTTP/HTTPS,
  useful when direct connections are blocked by firewalls.</p>
  
  <h4>Setup</h4>
  <p>Configure your tokens in your <code>.patchwork/auth.yaml</code> file:</p>
  <pre>tokens:
  your_secure_token:
    huproxy:
      - "*"  # Allow all hosts and ports
      - "*.example.com:*"  # Or restrict to specific patterns</pre>
  
  <h4>Usage</h4>
  <pre># Using with SSH and a WebSocket client
ssh -o 'ProxyCommand=huproxyclient -auth=Bearer:your_token {{.WebSocketURL}}/huproxy/alice/targethost/22' user@targethost

# Testing connectivity
curl -H "Authorization: Bearer your_token" \
     --http1.1 \
     --upgrade websocket \
     {{.BaseURL}}/huproxy/alice/localhost/22</pre>

  <h2>Tools</h2>
  <p>
    You can download a bash based client
    <a href="/static/patchwork.sh">here</a>.
  </p>
</body>

</html>
