<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Patchwork</title>
  <link rel="stylesheet" href="/static/water.css" />
</head>

<body>
  <img style="float: right" src="./android-chrome-192x192.png" alt="Patchwork logo" width="96" height="96" />
  <h1>Patchwork</h1>
  <p>
    A simple communication backend for scripts and other small applications.
    Patchwork enables IFTTT-type applications by providing infinite HTTP endpoints
    that serve as a multi-process, multi-consumer (MPMC) queue.
  </p>

  <h2>What does it do?</h2>
  <p>
    Patchwork provides infinite HTTP endpoints that can be used to implement powerful
    serverless applications - including desktop notifications, SMS notifications,
    job queues, web hosting, and file sharing. These applications are basically
    just a few lines of bash that wrap a <code>curl</code> command.
  </p>

  <h2>Basics</h2>
  <p>
    The philosophy behind this is that the main logic happens on the local machine
    with small scripts. There is a server with an infinite number of virtual channels
    that will relay messages between the publisher and the subscriber.
  </p>
  
  <p>To subscribe to a channel you can simply make a <code>GET</code> request:</p>
  <pre>curl {{.BaseURL}}/public/queue/a61b1f42</pre>
  
  <p>The above will block until something is published to the channel <code>a61b1f42</code>. 
  You can easily publish to a channel using a <code>POST</code> request:</p>
  <pre>curl {{.BaseURL}}/public/queue/a61b1f42 -d "hello, world"</pre>
  
  <p>The subscriber will immediately receive that data. If you reverse the order,
  then the post will block until it is received.</p>

  <h3>Pubsub mode</h3>
  <p>
    The default mode is a MPMC queue, where the first to connect are able to
    publish/subscribe. But you can also specify publish-subscribe (pubsub) mode.
    In pubsub mode, the publisher will become non-blocking and their data will be
    transmitted to each connected subscriber:
  </p>
  <pre>curl {{.BaseURL}}/public/pubsub/a61b1f42 -d "hello, world"</pre>
  
  <p>Or use the flexible namespace with the pubsub parameter:</p>
  <pre>curl {{.BaseURL}}/public/./a61b1f42?pubsub=true -d "hello, world"</pre>

  <h3>Publish with GET</h3>
  <p>
    You can also publish with a <code>GET</code> request by using the parameter
    <code>body=X</code>, making it easier to write href links that can trigger hooks:
  </p>
  <pre>curl {{.BaseURL}}/p/a61b1f42?pubsub=true&body=hello,%20world</pre>

  <h2>Behavior Patterns</h2>
  <p>Patchwork supports behavior determination based on the path structure, providing more predictable and explicit communication patterns:</p>

  <h3>Queue Behavior (Blocking)</h3>
  <p><strong>Paths:</strong> <code>/queue/...</code> or <code>/./...</code> (default)</p>
  <p>In queue mode, producers will block until a consumer is available to receive the data. This ensures one-to-one communication and guarantees message delivery.</p>
  <pre># Producer blocks until consumer connects
curl {{.BaseURL}}/public/queue/jobs -d "process-file.txt"

# Consumer receives the message
curl {{.BaseURL}}/public/queue/jobs</pre>

  <h3>Pubsub Behavior (Non-blocking)</h3>
  <p><strong>Paths:</strong> <code>/pubsub/...</code> or <code>/./...?pubsub=true</code></p>
  <p>In pubsub mode, producers send data immediately and don't wait for consumers. All connected consumers receive the same message (broadcast).</p>
  <pre># Producer sends immediately (non-blocking)
curl {{.BaseURL}}/public/pubsub/events -d "user-login"

# Multiple consumers can receive the same event
curl {{.BaseURL}}/public/pubsub/events  # Consumer 1
curl {{.BaseURL}}/public/pubsub/events  # Consumer 2</pre>

  <h3>Flexible Behavior</h3>
  <p><strong>Paths:</strong> <code>/./...</code></p>
  <p>The flexible space defaults to queue behavior but can be switched to pubsub with the <code>?pubsub=true</code> query parameter:</p>
  <pre># Default: queue behavior (blocking)
curl {{.BaseURL}}/public/./notifications -d "alert"

# Override: pubsub behavior (non-blocking)
curl {{.BaseURL}}/public/./notifications?pubsub=true -d "broadcast"</pre>

  <h2>Passthrough Headers</h2>
  <p>Patchwork supports passthrough headers using the <code>Patch-H-*</code> prefix system, allowing you to forward original request context between clients through the relay system.</p>

  <h3>How It Works</h3>
  <ul>
    <li><strong>Request Headers:</strong> Headers starting with <code>Patch-H-</code> represent original headers from the requester</li>
    <li><strong>Response Headers:</strong> <code>Patch-H-*</code> headers are stripped of their prefix and passed through to the final receiver</li>
    <li><strong>Automatic Headers:</strong> Common headers like <code>User-Agent</code>, <code>Accept</code>, etc. are automatically converted to <code>Patch-H-*</code> format</li>
  </ul>

  <h3>Example Usage</h3>
  <p><strong>Producer side</strong> (sending headers):</p>
  <pre>curl -X POST \
  -H "Patch-H-Original-IP: 192.168.1.100" \
  -H "Patch-H-User-ID: alice123" \
  -H "User-Agent: MyApp/1.0" \
  -d "request data" \
  {{.BaseURL}}/public/queue/api</pre>

  <p><strong>Consumer side</strong> (receiving headers):</p>
  <pre>curl -v {{.BaseURL}}/public/queue/api
# Response includes:
# Original-IP: 192.168.1.100
# User-ID: alice123
# User-Agent: MyApp/1.0</pre>

  <p>This enables building proxy-like applications where the original request context is preserved through the relay.</p>

  <h2>Namespaces</h2>
  <p>The server is organized by namespaces with different access patterns. Each namespace now supports structured sub-paths that determine the communication behavior:</p>

  <h3>Namespace Structure</h3>
  <p>All namespaces (public, user, etc.) now support the following sub-paths:</p>
  <ul>
    <li><strong>/_/...</strong> → Special control endpoints (user-owned namespaces only)</li>
    <li><strong>/./...</strong> → Flexible space - defaults to blocking/queue behavior, can be switched to pubsub with <code>?pubsub=true</code></li>
    <li><strong>/pubsub/...</strong> → All requests use pubsub behavior (non-blocking, broadcast to all consumers)</li>
    <li><strong>/queue/...</strong> → All requests use blocking/queue behavior (one-to-one communication)</li>
  </ul>

  <h3>Available Namespaces</h3>
  <ul>
    <li>
      <strong>/public/**</strong>: Public namespace - no authentication required.
      Everyone can read and write. Perfect for testing and public communication channels.
      <br><em>Examples: /public/queue/jobs, /public/pubsub/events</em>
    </li>
    <li>
      <strong>/p/**</strong>: Legacy public namespace - maintained for backward compatibility.
      Maps to the public namespace with default behavior.
    </li>
    <li>
      <strong>/h/**</strong>: Forward hooks - GET <code>/h</code> to obtain a new channel and secret,
      then use the secret to POST data to that channel. Anyone can GET data from the channel.
      Useful for webhooks and notifications where you want to control who can send.
    </li>
    <li>
      <strong>/r/**</strong>: Reverse hooks - GET <code>/r</code> to obtain a new channel and secret,
      then anyone can POST data to that channel. Use the secret to GET data from the channel.
      Useful for collecting data from multiple sources where you want to control who can read.
    </li>
    <li>
      <strong>/u/{username}/**</strong>: User namespace - controlled by ACL lists.
      Access is controlled by YAML ACL files stored in Forgejo/Gitea repositories 
      that specify which tokens can access which paths. Includes notification endpoints
      (<code>/_/ntfy</code>) for sending alerts and messages.
    </li>
    <li>
      <strong>/huproxy/{user}/{host}/{port}</strong>: HTTP-to-TCP WebSocket proxy for tunneling SSH and other protocols.
      Based on Google's HUProxy project, this endpoint provides WebSocket tunneling primarily for SSH
      connections. Uses token-based authentication via <code>Authorization</code> header. Tokens are managed through
      a <code>config.yaml</code> file in the user's <code>.patchwork</code> repository.
    </li>
  </ul>

  <h3>User Namespaces</h3>
  <p>
    For user namespaces (<code>/u/{username}/</code>), access is controlled by tokens
    that you configure in your own <code>.patchwork</code> repository. Create a 
    <code>.patchwork</code> repository in your account and add a <code>config.yaml</code> 
    file to define tokens, permissions, notification settings, and HuProxy access.
  </p>
  
  <h4>config.yaml Format</h4>
  <p>Create a <code>config.yaml</code> file in your <code>.patchwork</code> repository:</p>
  <pre>tokens:
  "my_token_name":
    is_admin: false
    POST: 
      - "/projects/*/logs"    # Can POST to any project's logs
      - "/webhooks/*"         # Can POST to webhook endpoints
      - "/_/ntfy"            # Can send notifications
    GET: 
      - "/projects/myapp/**"  # Can GET from all myapp paths
      - "!/projects/myapp/secret/**" # But not from secret paths
    huproxy:
      - "*.example.com:*"    # Can access specific hosts via HuProxy
      - "localhost:*"
      
  "readonly_token":
    is_admin: false
    POST: []               # No POST access
    GET: 
      - "*"               # Can GET from all paths
      
  "admin_token":
    is_admin: true
    POST: ["*"]
    GET: ["*"]

# Optional: Configure notification backend
ntfy:
  type: matrix
  config:
    access_token: "your_matrix_access_token"
    user: "@bot:matrix.org"
    endpoint: "https://matrix.org"
    room_id: "!roomid:matrix.org"</pre>
  
  <p>
    Use glob patterns to control access: <code>*</code> matches everything, 
    empty array <code>[]</code> denies access, and negation patterns like 
    <code>!secret/**</code> can exclude specific paths.
  </p>
  
  <p>
    Example token usage:
  </p>
  <pre>curl {{.BaseURL}}/u/alice/projects/logs?token=my_token_name -d "Deploy completed"</pre>

  <h4>Notification System</h4>
  <p>Send notifications via the <code>/_/ntfy</code> endpoint:</p>
  <pre># JSON notification
curl -X POST "{{.BaseURL}}/u/alice/_/ntfy" \
  -H "Authorization: Bearer my_token_name" \
  -H "Content-Type: application/json" \
  -d '{"type": "markdown", "title": "Alert", "content": "Something **important** happened!"}'

# Plain text notification  
curl -X POST "{{.BaseURL}}/u/alice/_/ntfy" \
  -H "Authorization: Bearer my_token_name" \
  -H "Content-Type: text/plain" \
  -d "Server maintenance completed"</pre>

  <h2>Modes</h2>
  <p>Each endpoint supports multiple modes:</p>
  <ul>
    <li><strong>queue</strong>: Each message is received by exactly one receiver (default)</li>
    <li><strong>pubsub</strong>: All receivers receive the published message</li>
    <li><strong>req/res</strong>: Request/response pattern (not implemented yet)</li>
  </ul>

  <h2>Examples</h2>

  <h3>Namespace Behavior Examples</h3>
  
  <p><strong>Queue behavior</strong> (one-to-one, blocking):</p>
  <pre># Producer waits until consumer connects
curl {{.BaseURL}}/public/queue/jobs -d "encode-video.mp4"

# Consumer receives the job
curl {{.BaseURL}}/public/queue/jobs</pre>

  <p><strong>Pubsub behavior</strong> (broadcast, non-blocking):</p>
  <pre># Producer sends immediately to all consumers
curl {{.BaseURL}}/public/pubsub/events -d "user-login:alice"

# Multiple consumers can listen
curl {{.BaseURL}}/public/pubsub/events  # Logger service
curl {{.BaseURL}}/public/pubsub/events  # Analytics service</pre>

  <p><strong>Flexible behavior</strong> with override:</p>
  <pre># Default blocking behavior
curl {{.BaseURL}}/public/./alerts -d "server-down"

# Override to pubsub
curl {{.BaseURL}}/public/./alerts?pubsub=true -d "system-update"</pre>

  <p><strong>Using passthrough headers</strong>:</p>
  <pre># Send with context headers
curl -X POST \
  -H "Patch-H-Client-IP: 10.0.1.5" \
  -H "Patch-H-Trace-ID: req-12345" \
  -d "api-request" \
  {{.BaseURL}}/public/queue/api

# Receive with original context
curl -v {{.BaseURL}}/public/queue/api
# Headers include: Client-IP: 10.0.1.5, Trace-ID: req-12345</pre>

  <h3>File Sharing</h3>
  <p>Sending a file:</p>
  <pre>curl -X POST --data-binary "@test.txt" {{.BaseURL}}/public/queue/files</pre>
  <p>Receiving a file:</p>
  <pre>curl {{.BaseURL}}/public/queue/files > test.txt</pre>

  <h3>Desktop Notifications (Linux)</h3>
  <pre>#!/bin/bash
MAGIC="notify"
URL="{{.BaseURL}}/p/notifications"

while [ 1 ]
do
  X="$(curl $URL)"
  if [[ $X =~ ^$MAGIC ]]; then
    Y="$(echo "$X" | sed "s/$MAGIC*//")"
    notify-send "$Y"
  else
    sleep 10
  fi
done</pre>

  <h3>Job Queue</h3>
  <p>Adding jobs to a queue:</p>
  <pre>#!/bin/bash
for filename in *.mp3
do
  curl {{.BaseURL}}/p/jobs -d $filename
done</pre>

  <p>Processing jobs from the queue:</p>
  <pre>#!/bin/bash
while true
do
  filename=$(curl -s {{.BaseURL}}/p/jobs)
  if [ "$filename" != "Too Many Requests" ]
  then
    echo "Processing: $filename"
    # Process the file here
    ffmpeg -i "$filename" "$filename.ogg"
  else
    sleep 1
  fi
done</pre>

  <h3>Forward Hook Example</h3>
  <p>To use forward hooks, first obtain a channel and secret:</p>
  <pre># Get a new channel and secret
curl {{.BaseURL}}/h
# Returns: {"channel":"abc123-def456-...","secret":"sha256hash..."}

# Send notification (requires secret)
curl {{.BaseURL}}/h/abc123-def456-...?secret=sha256hash... -d "Server is down!"

# Anyone can listen for notifications
curl {{.BaseURL}}/h/abc123-def456-...</pre>

  <h3>Reverse Hook Example</h3>
  <p>Similarly, for reverse hooks, obtain a channel and secret:</p>
  <pre># Get a new channel and secret
curl {{.BaseURL}}/r
# Returns: {"channel":"xyz789-abc123-...","secret":"sha256hash..."}

# Anyone can submit metrics
curl {{.BaseURL}}/r/xyz789-abc123-... -d "cpu:85%"
curl {{.BaseURL}}/r/xyz789-abc123-... -d "memory:67%"

# Reading requires secret
curl {{.BaseURL}}/r/xyz789-abc123-...?secret=sha256hash...</pre>

  <p><strong>Note</strong>: The secrets are generated using HMAC-SHA256 with a server secret key and the channel name. 
  Set the <code>SECRET_KEY</code> environment variable to ensure secrets persist across server restarts.</p>

  <h3>SSH over WebSocket Tunneling</h3>
  <p>The huproxy endpoint allows you to tunnel SSH and other TCP protocols through HTTP/HTTPS,
  useful when direct connections are blocked by firewalls.</p>
  
  <h4>Setup</h4>
  <p>Configure your tokens in your <code>.patchwork/config.yaml</code> file:</p>
  <pre>tokens:
  "your_secure_token":
    huproxy:
      - "*"  # Allow all hosts and ports
      - "*.example.com:*"  # Or restrict to specific patterns</pre>
  
  <h4>Usage</h4>
  <pre># Using with SSH and a WebSocket client
ssh -o 'ProxyCommand=huproxyclient -auth=Bearer:your_token {{.WebSocketURL}}/huproxy/alice/targethost/22' user@targethost

# Testing connectivity
curl -H "Authorization: Bearer your_token" \
     --http1.1 \
     --upgrade websocket \
     {{.BaseURL}}/huproxy/alice/localhost/22</pre>

  <h2>Tools</h2>
  <p>
    You can download a bash based client
    <a href="/static/patchwork.sh">here</a>.
  </p>
</body>

</html>
