<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Patchwork</title>
  <link rel="stylesheet" href="/static/water.css" />
</head>

<body>
  <img style="float: right" src="./android-chrome-192x192.png" alt="Patchwork logo" width="96" height="96" />
  <h1>Patchwork</h1>
  <p>
    A simple communication backend for scripts and other small applications.
    Patchwork enables IFTTT-type applications by providing infinite HTTP endpoints
    that serve as a multi-process, multi-consumer (MPMC) queue.
  </p>

  <h2>What does it do?</h2>
  <p>
    Patchwork provides infinite HTTP endpoints that can be used to implement powerful
    serverless applications - including desktop notifications, SMS notifications,
    job queues, web hosting, and file sharing. These applications are basically
    just a few lines of bash that wrap a <code>curl</code> command.
  </p>

  <h2>Basics</h2>
  <p>
    The philosophy behind this is that the main logic happens on the local machine
    with small scripts. There is a server with an infinite number of virtual channels
    that will relay messages between the publisher and the subscriber.
  </p>
  
  <p>To subscribe to a channel you can simply make a <code>GET</code> request:</p>
  <pre>curl https://patchwork.example.com/p/a61b1f42</pre>
  
  <p>The above will block until something is published to the channel <code>a61b1f42</code>. 
  You can easily publish to a channel using a <code>POST</code> request:</p>
  <pre>curl https://patchwork.example.com/p/a61b1f42 -d "hello, world"</pre>
  
  <p>The subscriber will immediately receive that data. If you reverse the order,
  then the post will block until it is received.</p>

  <h3>Pubsub mode</h3>
  <p>
    The default mode is a MPMC queue, where the first to connect are able to
    publish/subscribe. But you can also specify publish-subscribe (pubsub) mode.
    In pubsub mode, the publisher will become non-blocking and their data will be
    transmitted to each connected subscriber:
  </p>
  <pre>curl https://patchwork.example.com/p/a61b1f42?pubsub=true -d "hello, world"</pre>

  <h3>Publish with GET</h3>
  <p>
    You can also publish with a <code>GET</code> request by using the parameter
    <code>body=X</code>, making it easier to write href links that can trigger hooks:
  </p>
  <pre>curl https://patchwork.example.com/p/a61b1f42?pubsub=true&body=hello,%20world</pre>

  <h2>Namespaces</h2>
  <p>The server is organized by namespaces with different access patterns:</p>
  <ul>
    <li>
      <strong>/p/**</strong>: Public namespace - no authentication required.
      Everyone can read and write. Perfect for testing and public communication channels.
    </li>
    <li>
      <strong>/h/**</strong>: Forward hooks - GET <code>/h</code> to obtain a new channel and secret,
      then use the secret to POST data to that channel. Anyone can GET data from the channel.
      Useful for webhooks and notifications where you want to control who can send.
    </li>
    <li>
      <strong>/r/**</strong>: Reverse hooks - GET <code>/r</code> to obtain a new channel and secret,
      then anyone can POST data to that channel. Use the secret to GET data from the channel.
      Useful for collecting data from multiple sources where you want to control who can read.
    </li>
    <li>
      <strong>/u/{username}/**</strong>: User namespace - controlled by ACL lists
      (not implemented yet). Access is controlled by YAML ACL files stored in
      Forgejo/Gitea repositories that specify which tokens can access which paths.
    </li>
    <li>
      <strong>/huproxy/{user}/{host}/{port}</strong>: HTTP-to-TCP WebSocket proxy for tunneling SSH and other protocols.
      Based on Google's HUProxy project, this endpoint provides WebSocket tunneling primarily for SSH
      connections. Uses token-based authentication via <code>Authorization</code> header. Tokens are managed through
      a <code>huproxy.yaml</code> file in the user's <code>.patchwork</code> repository.
    </li>
  </ul>

  <h3>ACL File Format</h3>
  <p>
    For user namespaces, access control is managed through YAML files stored in
    Forgejo/Gitea repositories. Each user or organization can create a 
    <code>.patchwork</code> repository containing an <code>auth.yaml</code> file
    that defines permissions for different tokens:
  </p>
  <pre>some_token_name:
  POST: "projects/*/data"  # Can POST to any project's data endpoint
  GET: "projects/myproject/**"  # Can GET from all paths under myproject

restricted_token:
  POST: ""  # Empty string means no POST access allowed
  GET: "**"  # Can GET from all subpaths in this namespace

webhook_token:
  POST: "webhooks/*"  # Can POST to any webhook endpoint
  GET: "status"  # Can only GET the status endpoint</pre>
  <p>
    Each token can have <code>POST</code> and <code>GET</code> permissions defined
    with glob patterns. An empty string denies all access for that method, while
    <code>**</code> allows access to all subpaths.
  </p>
  <p>
    The patchwork server pulls these ACL files from the configured Forgejo/Gitea
    instance (<code>{{.ForgejoURL}}</code>) as needed and caches them for {{.ACLTTL}}. A special 
    <code>patchwork</code> user should be given read access to the 
    <code>.patchwork</code> repositories.
  </p>

  <h2>Modes</h2>
  <p>Each endpoint supports multiple modes:</p>
  <ul>
    <li><strong>queue</strong>: Each message is received by exactly one receiver (default)</li>
    <li><strong>pubsub</strong>: All receivers receive the published message</li>
    <li><strong>req/res</strong>: Request/response pattern (not implemented yet)</li>
  </ul>

  <h2>Examples</h2>

  <h3>File Sharing</h3>
  <p>Sending a file:</p>
  <pre>curl -X POST --data-binary "@test.txt" https://patchwork.example.com/p/test.txt</pre>
  <p>Receiving a file:</p>
  <pre>wget https://patchwork.example.com/p/test.txt</pre>

  <h3>Desktop Notifications (Linux)</h3>
  <pre>#!/bin/bash
MAGIC="notify"
URL="https://patchwork.example.com/p/notifications"

while [ 1 ]
do
  X="$(curl $URL)"
  if [[ $X =~ ^$MAGIC ]]; then
    Y="$(echo "$X" | sed "s/$MAGIC*//")"
    notify-send "$Y"
  else
    sleep 10
  fi
done</pre>

  <h3>Job Queue</h3>
  <p>Adding jobs to a queue:</p>
  <pre>#!/bin/bash
for filename in *.mp3
do
  curl https://patchwork.example.com/p/jobs -d $filename
done</pre>

  <p>Processing jobs from the queue:</p>
  <pre>#!/bin/bash
while true
do
  filename=$(curl -s https://patchwork.example.com/p/jobs)
  if [ "$filename" != "Too Many Requests" ]
  then
    echo "Processing: $filename"
    # Process the file here
    ffmpeg -i "$filename" "$filename.ogg"
  else
    sleep 1
  fi
done</pre>

  <h3>Forward Hook Example</h3>
  <p>To use forward hooks, first obtain a channel and secret:</p>
  <pre># Get a new channel and secret
curl https://patchwork.example.com/h
# Returns: {"channel":"abc123-def456-...","secret":"sha256hash..."}

# Send notification (requires secret)
curl https://patchwork.example.com/h/abc123-def456-...?secret=sha256hash... -d "Server is down!"

# Anyone can listen for notifications
curl https://patchwork.example.com/h/abc123-def456-...</pre>

  <h3>Reverse Hook Example</h3>
  <p>Similarly, for reverse hooks, obtain a channel and secret:</p>
  <pre># Get a new channel and secret
curl https://patchwork.example.com/r
# Returns: {"channel":"xyz789-abc123-...","secret":"sha256hash..."}

# Anyone can submit metrics
curl https://patchwork.example.com/r/xyz789-abc123-... -d "cpu:85%"
curl https://patchwork.example.com/r/xyz789-abc123-... -d "memory:67%"

# Reading requires secret
curl https://patchwork.example.com/r/xyz789-abc123-...?secret=sha256hash...</pre>

  <p><strong>Note</strong>: The secrets are generated using HMAC-SHA256 with a server secret key and the channel name. 
  Set the <code>SECRET_KEY</code> environment variable to ensure secrets persist across server restarts.</p>

  <h3>SSH over WebSocket Tunneling (huproxy) Example</h3>
  <p>The huproxy endpoint provides WebSocket tunneling for SSH and other TCP protocols, based on Google's
  HUProxy project. This allows tunneling SSH connections through HTTP/HTTPS when direct SSH access is
  restricted by firewalls or network policies.</p>
  
  <h4>Token Configuration</h4>
  <p>First, configure tokens in your <code>.patchwork/huproxy.yaml</code> file:</p>
  <pre>tokens:
  - "your_secure_token_here"
  - "another_token_for_different_client"</pre>
  
  <h4>SSH Client Configuration</h4>
  <pre># Using a WebSocket client like huproxyclient (needs to be built separately)
ssh -o 'ProxyCommand=huproxyclient -auth=Bearer:your_secure_token_here wss://patchwork.example.com/huproxy/alice/targethost/22' user@targethost

# Or using curl as a basic test (won't work for full SSH sessions)
curl -H "Authorization: Bearer your_secure_token_here" \
     --http1.1 \
     --upgrade websocket \
     https://patchwork.example.com/huproxy/alice/localhost/22</pre>
  
  <p><strong>Security Notes</strong>:</p>
  <ul>
    <li>Tokens are validated against the user's <code>.patchwork/huproxy.yaml</code> file</li>
    <li>Each user controls their own token list through their repository</li>
    <li>Tokens should be long, random strings (recommended: 32+ characters)</li>
    <li>The proxy supports any TCP service, not just SSH (databases, VNC, etc.)</li>
  </ul>
  
  <p><strong>Original Project</strong>: This implementation is based on 
  <a href="https://github.com/google/huproxy">Google's HUProxy</a> with added user-specific 
  authentication and integration into the Patchwork ecosystem.</p>

  <h2>Tools</h2>
  <p>
    You can download a bash based client
    <a href="/static/patchwork.sh">here</a>.
  </p>
</body>

</html>
